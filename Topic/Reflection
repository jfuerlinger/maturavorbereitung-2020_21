
#### Reflection

#####  1.Grundkonzept

 Reflection stellt Objekte vom Typ Type bereit, die Assemblies, Module und Typen beschreiben.
Die Reflections können  verwendet werden um dynamisch eine Instanz eines Typs zu erstellen, den Typ an ein vorhandenes Objekt zu binden oder den Typ von einem vorhandenen Objekt abzurufen und seine Methoden aufzurufen oder auf seine Felder und Eigenschaften zuzugreifen
Es ist auch Möglich mit der Reflection auf die Atributte in dem Code zu greifen. 


##### 2.Einsatzmöglichkeiten

 - Zugriff auf die Metadaten des Programms
 - Zum Untersuchen und Instanziieren von Typen in einer Assembly.
 - Erstellung neuer Typen in der Laufzeit.
 - Late Binding: der Zugriff auf Methoden für Typen welche in der Laufzeit erstellt werden.


Der **Common Language Runtime Loader** verwaltet Anwendungsdomänen, die definierte Grenzen um Objekte darstellen, die den gleichen Anwendungsbereich haben. Diese Verwaltung umfasst das Laden jeder Assembly in die entsprechende Anwendungsdomäne und die Steuerung des Speicherlayouts der Typenhierarchie innerhalb jeder Assembly.


Als **Common Language Runtime (CLR)** bezeichnete Laufzeitumgebung bereit, die Code ausführt und Dienste zum Vereinfachen des Entwicklungsprozesses bereitstellt.Compiler und Tools machen die Funktionen der Common Language Runtime verfügbar und ermöglichen das Schreiben von Code, mit dem die Vorteile dieser verwalteten Ausführungsumgebung genutzt werden können.



##### Reflection in .NET

Die Klassen im System.Reflection-Namespace ermöglichen es zusammen mit System.Type, Informationen zu geladenen Assemblys und den hierin definierten Typen wie Klassen, Schnittstellen und Werttypen (also Strukturen und Enumerationen) abzurufen. Mithilfe von Reflection kann auch Typeninstanzen zur Laufzeit erstellt werde, diese aufrufen und darauf zugreifen. 
Das Common Language Runtime-Ladeprogramm verwaltet Anwendungsdomänen, bei denen es sich um definierte Begrenzungen um Objekte im gleichen Anwendungsbereich handelt. Diese Verwaltung umfasst das Laden jeder Assembly in die geeignete Anwendungsdomäne und das Steuern des Speicherlayouts der Typenhierarchie in jeder Assembly.

Assemblys <=> Module <=> Typen <=> Member

Assemblys enthalten Module, Module enthalten Typen, und Typen enthalten Member. Mit der Reflection werden Objekte bereitgestellt, die Assemblys, Module und Typen kapseln.  Mithilfe von Reflection kann dynamisch eine Instanz eines Typen erzeugt werden, Typen an ein vorhandenes Objekt gebunden werden und Typinformationen eines vorhandenen Objekts abfragen. Sie können anschließend die Methoden des Typs aufrufen oder auf dessen Felder oder Eigenschaften zugreifen.

 Typische Verwendungen von Reflectionen umfassen die folgenden:
Verwendung von Assembly, um Assemblys zu definieren und zu laden, um Module zu laden, die im Assemblymanifest aufgeführt sind, und um einen Typ in seiner Assembly zu suchen und eine Instanz hiervon zu erstellen.
 - Verwendung von Module, um Informationen zu ermitteln, wie die Assembly, die das Modul       	enthält, und die Klassen im Modul. Es können auch alle globalen Methoden oder andere 	spezifische, nicht globale Methoden abrufen, die im Modul definiert sind.
 - Verwendung von ConstructorInfo, um Informationen wie den Namen, die Parameter, die 	Zugriffsmodifizierer (wie public oder private) und Details zur Implementierung (wie 	abstract oder virtual) für einen Konstruktor abzurufen. 
 - Verwendung von MethodInfo, um Informationen wie den Namen, den Rückgabetyp, die 	Parameter, die Zugriffsmodifizierer (wie public oder private) und Details zur 	Implementierung (wie abstract oder virtual) für eine Methode abzurufen
 - Verwendung von FieldInfo, um Informationen wie den Namen, die Zugriffsmodifizierer (wie 	public oder private) und Details zur Implementierung (wie static) für ein Feld abzurufen 	oder die Feldwerte abzurufen oder festzulegen.
 - Verwendung von EventInfo, um Informationen wie den Namen, den Datentyp das 	Ereignishandlers, benutzerdefinierte Attribute, den Deklarationstyp und den reflektierten 	Typ eines Ereignisses abzurufen und um Ereignishandler hinzuzufügen oder zu entfernen.
 - Verwendung von PropertyInfo, um Informationen wie den Namen, den Datentyp, den 	Deklarationstyp, den reflektierten Typ und die Status "Schreibgeschützt" oder 	"Beschreibbar" einer Eigenschaft abzurufen und um die Eigenschaftswert abzurufen oder 	festzulegen.
 - Verwendung von ParameterInfo, um Informationen wie den Namen eines Parameters, den 	Datentyp, ob es sich um einen Eingabe- oder Ausgabeparameter handelt und die Position des 	Parameters in der Methodensignatur abzurufen.
 - Verwendung von CustomAttributeData, um Informationen zu benutzerdefinierten Attributen  	abzurufen, wenn Sie im ausschließlich Reflectionsbezogenen Kontext einer 	Anwendungsdomäne arbeiten. CustomAttributeData ermöglicht ea, Attribute zu überprüfen, 	ohne Instanzen hiervon erstellen zu müssen.

Reflectionen können auch zum Erstellen von Anwendungen verwendet werden, die als Typbrowser bezeichnet werden und es dem Benutzer ermöglichen, Typen auszuwählen und dann Informationen zu diesen Typen anzuzeigen.
Dies ist eine weitere Verwendungsmöglichkeit von Reflectionen. Compiler für Sprachen wie JScript verwenden Reflectionen, um Symboltabellen zu erstellen. 
Reflection stellt Klassen wie Type und MethodInfo bereit, um Typen, Member, Parameter und andere Codeentitäten darzustellen. Wenn Sie jedoch Reflection verwenden, arbeiten Sie nicht direkt mit diesen Klassen, von denen die meisten abstrakt sind ( Stattdessen arbeiten Sie mit Typen, die von der CLR (Common Language Runtime) bereitgestellt werden.
Diese Laufzeitklassen sind internal. Sie werden nicht getrennt von den Basisklassen dokumentiert, da ihr Verhalten in der Dokumentation der Basisklasse beschrieben wird.



###### Assembly zusammenfassung
Die Assemblys bilden die Grundlage für .NET-basierte Anwendungen
Assembly können statisch oder dynamisch sein
 Eine Assembly ist eine Auflistung von Typen und Ressourcen, die so erstellt wurden, dass sie zusammenarbeiten und eine logische funktionelle Einheit bilden.

Jede Assembly enthält eine Assemblymanifestdatei. Ähnlich wie ein Inhaltsverzeichnis enthält das Assemblymanifest Folgendes:
Die Identität der Assembly (Name und Version).
Eine Dateitabelle, die alle anderen Dateien beschreibt, aus denen die Assembly besteht, z.B. weitere Assemblys, die Sie erstellt haben, von denen Ihre EXE- oder DLL-Datei abhängig ist, oder sogar Bitmap- oder Infodateien.
Eine Assemblyverweisliste, also eine Liste aller externen Abhängigkeiten, z.B. DLL-Dateien oder andere Dateien. Assemblyverweise enthalten Verweise auf globale und private Objekte. Globale Objekte stehen für alle weiteren Anwendungen zur Verfügung. 

Assemblys bilden die Grundlage für die Bereitstellung, die Versionskontrolle, die Wiederverwendung, die Festlegung des Aktivierungsumfangs und die Sicherheitsberechtigungen für .NET-basierte Anwendungen. Eine Assembly ist eine Auflistung von Typen und Ressourcen, die so erstellt wurden, dass sie zusammenarbeiten und eine logische funktionelle Einheit bilden. Assemblys sind ausführbare Dateien ( .exe) oder Dynamic Link Library-Dateien ( .dll) und bilden die Bausteine von .NET-Anwendungen. Sie stellen der Common Language Runtime die Informationen zur Verfügung, die sie zum Erkennen der Typimplementierungen benötigt.
In .NET Core und .NET Framework können   Assemblys entweder aus einer oder aus mehreren Quellcodedateien erstellt werden. In .NET Framework können Assemblys ein Modul oder mehrere Module umfassen. Dies macht es möglich, größere Projekte so zu planen, dass mehrere Entwickler an verschiedenen Quellcodedateien oder Modulen arbeiten, die anschließend in einer einzigen Assembly kombiniert werden.

##### Assemblys verfügen über folgende Eigenschaften:
Assemblys werden als EXE- oder DLL-Dateien implementiert.
Für Bibliotheken, die auf .NET Framework ausgerichtet sind, können  Assemblys für mehrere Anwendungen freigeben werden, indem diese im globalen Assemblycache abgelegt werden. Den Assemblys sollen am besten  starke Namen gegeben werden, bevor  sie zum globalen Assemblycache hinzufügt werden sollen. 
Assemblys werden nur in den Arbeitsspeicher geladen, wenn sie erforderlich sind. Wenn sie nicht verwendet werden, werden sie auch nicht geladen. Dies bedeutet, dass Assemblys eine effiziente Möglichkeit zur Verwaltung von Ressourcen in größeren Projekten sein können.
Mithilfe der Reflection können programmgesteuert Informationen zu einer Assembly abgerufen werden. 
Man kann die Assemblys auch nur laden um sie zu untersuchen. 

##### Assemblys in der Common Language Runtime (CLR)
Assemblys stellen der Common Language Runtime die Informationen zur Verfügung, die  zur Erkennen von Typimplementierungen benötigt werden. Für die Common Language Runtime sind Typen nur im Kontext einer Assembly vorhanden.
Eine Assembly definiert die folgenden Informationen:
Code, der von der Common Language Runtime ausgeführt wird. Wichtig ist das Assemblys nur über einen Einstiegspunkt  verfügt sein kann.
Sicherheitsgrenze. Eine Assembly ist die Einheit, bei der Berechtigungen angefordert und erteilt werden. 
Typgrenze. Die Identität jedes Typs enthält den Namen der Assembly, in der dieser sich befindet. Wenn der Typ MyType in den Gültigkeitsbereich einer Assembly geladen wird, ist dieser nicht derselbe wie der Typ MyType, der in den Gültigkeitsbereich einer anderen Assembly geladen wurde.
Grenzen für Gültigkeitsbereiche. Das Assemblymanifest enthält Metadaten, die für das Auflösen von Typen und die Bereitstellung angeforderter Ressourcen verwendet werden. Das Manifest gibt die Typen und Ressourcen an, die außerhalb der Assembly verfügbar gemacht werden sollen, und listet andere Assemblys auf, von denen es abhängig ist.  Die Assembly ist die kleinste versionierbare Einheit in der Common Language Runtime. Alle Typen und Ressourcen in derselben Assembly werden als eine Einheit versioniert. Das Assemblymanifest beschreibt die von Ihnen für abhängige Assemblys angegebenen Versionsabhängigkeiten. 
Bereitstellungseinheit. Beim Starten einer Anwendung müssen nur die von der Anwendung zu Beginn aufgerufenen Assemblys vorhanden sein. Andere Assemblys, z.B. Assemblys mit Lokalisierungsressourcen oder Hilfsklassen, können bei Bedarf abgerufen werden. Dadurch ist die App beim ersten Herunterladen einfach und schlank. 



##### Reflection und generische Typen

Aus Sicht der Reflexion besteht der Unterschied zwischen einem generischen und einem normalen Typ darin, dass ein generischer Typ mit einem Typparameterset (bei einer generischen Typdefinition) oder mit Typargumenten (bei einem konstruierten Typ) verknüpft ist. Auf dieselbe Art unterscheidet sich eine generische Methode von einer normalen Methode.
Es gibt zwei wichtige Schlüssel für das Verständnis des Umgangs von Reflection mit generischen Typen und Methoden:
Die Typparameter der generischen Typdefinitionen und generischen Methodendefinitionen werden durch Instanzen der Type -Klasse dargestellt.

Wenn eine Instanz des Type -Objekts einen generischen Typ darstellt, enthält es ein Array von Typen, das die Typparameter (bei generischen Typdefinitionen) oder die Typargumente (bei konstruierten Typen) darstellt. Gilt auch für eine Instanz der MethodInfo -Klasse, die eine generische Methode darstellt.
Reflection stellt Type- und MethodInfo-Methoden bereit, mit denen Sie auf das Array von Typparametern zugreifen und ermitteln können, ob eine Type-Instanz einen Typparameter oder einen tatsächlichen Typ darstellt.

####Quellen
https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection
https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/
https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection-and-generic-types
